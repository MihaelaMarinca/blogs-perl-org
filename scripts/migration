#!/usr/bin/env perl

use strict;
use warnings;

use Encode;

use DBI;
use String::Dirify qw( dirify );
use Try::Tiny;
use Getopt::Long;

my ( $in_driver, $out_driver )     = ( 'mysql', 'Pg' );
my ( $in_database, $out_database ) = ( 'mt_blogs_perl_org', 'blogs_perl_org' );
my ( $in_user, $out_user )         = ( 'root', 'jgoff' );
my ( $in_password, $out_password ) = ( '', '' );

GetOptions(
  'in-driver=s'  => \$in_driver,
  'out-driver=s' => \$out_driver,
  'in-db=s'      => \$in_database,
  'out-db=s'     => \$out_database,
  'in-user=s'    => \$in_user,
  'out-user=s'   => \$out_user,
);

my $in_dsn  = "dbi:$in_driver:database=$in_database";
my $out_dsn = "dbi:$out_driver:database=$out_database";

my $in_dbh  = DBI->connect( $in_dsn, $in_user, $in_password );
my $out_dbh = DBI->connect( $out_dsn, $out_user, $out_password );

$|++;

my $AVATAR_PATH   = '/avatars';
my $PER_USER_PATH = '/users';

sub munge_asset_file_path {
  my $in_asset = shift;
  $in_asset->{asset_file_path} =~ s{^\%s}{$AVATAR_PATH};
  $in_asset->{asset_file_path} =~
    s{^\%r}{$PER_USER_PATH/$in_asset->{author_basename}};
}

###############################################################################

sub map_user {
  my $user = shift;
  return {
    id                 => $user->{author_id},
    name               => decode_utf8($user->{author_nickname}),
    username           => $user->{author_name},
    password           => $user->{author_password},
    preferred_language => $user->{author_preferred_language},
    register_date      => $user->{author_created_on},
    email              => decode_utf8($user->{author_email}),
    role               => $user->{author_is_superuser} ? 'admin' : 'author',
    status             => $user->{author_status} == 1 ? 'active' : 'inactive',
    biography          => decode_utf8($user->{author_meta_vclob}),
  };
}

sub migrate_users {
  my $in_sth = $in_dbh->prepare( <<'EOS' );
   SELECT a.author_id,
          a.author_nickname,
          a.author_name,
          a.author_password,
          a.author_preferred_language,
          a.author_created_on,
          a.author_email,
          a.author_is_superuser,
          a.author_status,
          am.author_meta_vclob
     FROM mt_author a
LEFT JOIN mt_author_meta am
       ON a.author_id = am.author_meta_author_id
 GROUP BY a.author_id
 ORDER BY a.author_id
EOS

  my @fields = qw( id name username password status preferred_language register_date email role biography );
  my $out_sth = $out_dbh->prepare( <<'EOS' );
INSERT INTO users(id,
                  name,
                  username,
                  password,
                  status,
                  preferred_language,
                  register_date,
                  email,
                  role,
                  biography)
           VALUES(?,?,?,?,?,?,?,?,?,?)
EOS

  $in_sth->execute();

  my $count = 0;
  while ( my $in_user = $in_sth->fetchrow_hashref  ) {
    print '.' if $count++ % 100 == 0;
#use Data::Dumper; print Dumper($in_user);
#last;
    my $out_user = map_user($in_user);
    try {
      $out_sth->execute(
        @{$out_user}{@fields}
      );
    }
    catch {
      die "Failed to insert user '$in_user->{name}: $_ $!\n";
    };
  }
}

###############################################################################

sub create_avatars {
  my $in_sth = $in_dbh->prepare( <<EOS );
SELECT author_id,
       author_basename,
       asset_file_path
  FROM mt_asset
  JOIN mt_author
    ON author_userpic_asset_id = asset_id
EOS

  my $out_sth = $out_dbh->prepare( <<'EOS' );
UPDATE users SET avatar_path = ? WHERE id = ?
EOS

  $in_sth->execute;

  my $count = 0;
  while ( my $in_asset = $in_sth->fetchrow_hashref ) {
    print '.' if $count++ % 100 == 0;
    munge_asset_file_path( $in_asset );
#use Data::Dumper; print Dumper($in_user);
#last;
    try {
      $out_sth->execute( $in_asset->{asset_file_path}, $in_asset->{author_id} );
    }
    catch {
      die "Failed to create avatar for '$in_asset->{author_id}: $_ $!\n";
    };
  }
}

###############################################################################

sub map_blog {
  my $blog = shift;
  my $dirified = dirify( $blog->{blog_name} );
  return {
    id           => $blog->{blog_id},
    name         => decode_utf8($blog->{blog_name}),
    slug         => decode_utf8($dirified),
    description  => decode_utf8($blog->{blog_description}),
    created_by   => $blog->{blog_created_by},
    created_date => $blog->{blog_created_on},
    edited_date  => $blog->{blog_modified_on},
  };
}

my %blog_user; # key $blog_id, value $user_id

sub migrate_blogs {
  my $in_sth = $in_dbh->prepare( 'SELECT * FROM mt_blog ORDER BY blog_id' );
#SELECT id FROM users WHERE name = ?

  my @fields = qw( id name slug description created_date edited_date );
  my $out_sth = $out_dbh->prepare( <<'EOS' );
INSERT INTO blog(id,name,slug,description,created_date,edited_date)
          VALUES(?,?,?,?,?,?)
EOS
  my $out_owner_sth = $out_dbh->prepare( <<'EOS' );
INSERT INTO blog_owners(blog_id,user_id)
          VALUES(?,?)
EOS

  $in_sth->execute;

  my $count  = 0;
  while ( my $in_blog = $in_sth->fetchrow_hashref ) {
    print '.' if $count++ % 100 == 0;

#use Data::Dumper; print Dumper($in_blog);
#last;
    my $out_blog = map_blog( $in_blog );
    next if $out_blog->{name} eq 'blogs.perl.org'; # Skip admin "user"

    $out_sth->execute( @{$out_blog}{@fields} );

    $blog_user{$out_blog->{id}} = $out_blog->{created_by};
    $out_owner_sth->execute($out_blog->{id},$out_blog->{created_by});
  }
}

###############################################################################

sub map_post {
  my $post = shift;
  my $dirified = dirify( $post->{entry_title} );
  return {
    id           => $post->{entry_id},
    title        => decode_utf8($post->{entry_title}),
    slug         => decode_utf8($dirified),
    description  => $post->{entry_basename}, # XXX ?
    #cover varchar(300) NOT NULL,
    content      => decode_utf8($post->{entry_text}),
    created_date => $post->{entry_authored_on},
    #type post_format DEFAULT 'HTML',
    #status post_status DEFAULT 'draft',
    status       => 'published', # XXX Imported posts are already published
    user_id      => $post->{entry_author_id},
    blog_id      => $post->{entry_blog_id},
  };
}

my %user_post; #key $user_id, value @{ $post_id }

sub migrate_posts {
  my $in_sth = $in_dbh->prepare( <<'EOS' );
  SELECT *
    FROM mt_entry
ORDER BY entry_id
EOS

  my $out_sth = $out_dbh->prepare( <<'EOS' );
INSERT INTO post(id,title,slug,description,content,created_date,status,user_id)
          VALUES(?,?,?,?,?,?,?,?)
EOS

  $in_sth->execute();

  my $count  = 0;
  while ( my $in_post = $in_sth->fetchrow_hashref ) {
    print '.' if $count++ % 100 == 0;
#use Data::Dumper; print Dumper($in_post);
#last;
    my $out_post = map_post( $in_post );
    push @{ $user_post{ $out_post->{user_id} } }, $out_post->{id};
    $out_sth->execute( @{$out_post}{@fields} );
  }
}

###############################################################################

sub map_comment {
  my $comment = shift;
  return {
    id           => $comment->{comment_id},
    content      => decode_utf8($comment->{comment_text}),
    fullname     => $comment->{comment_author},
    email        => $comment->{comment_email},
    website      => $comment->{comment_url},
#  avatar varchar(255) DEFAULT NULL,
    comment_date => $comment->{comment_created_on},
#  type post_format DEFAULT 'HTML', # Remain default
    status       => $comment->{comment_visible} == 1 ? 'approved' : 'pending',
    post_id      => $comment->{comment_entry_id},
    uid          => $comment->{comment_commenter_id},
  };
}

sub migrate_comments {
  my $in_sth = $in_dbh->prepare('SELECT * FROM mt_comment ORDER BY comment_id');
  my @fields = qw( id content fullname email website comment_date status post_id uid reply_to );
  my $out_sth = $out_dbh->prepare( <<'EOS' );
INSERT INTO comment(id,
                    content,
                    fullname,
                    email,
                    website,
                    comment_date,
                    status,
                    post_id,
                    uid,
                    reply_to)
            VALUES(?,?,?,?,?,?,?,?,?,?)
EOS
  $in_sth->execute();

  my $count  = 0;
  while ( my $in_comment = $in_sth->fetchrow_hashref ) {
    print '.' if $count++ % 100 == 0;
    next unless $in_comment->{comment_commenter_id}; # XXX Eliminate spam?
#use Data::Dumper; print Dumper($in_comment);
#last;
    my $out_comment = map_comment($in_comment);
    $out_sth->execute(
        @{$out_comment}{@fields}
    );
  }
}

###############################################################################

sub map_category {
  my $category = shift;
  my $dirified = dirify( $category->{category_label} );
  return {
    id      => $category->{category_id},
    name    => decode_utf8($category->{category_label}),
    slug    => decode_utf8($dirified),
    user_id => $category->{category_author_id},
    blog_id => $category->{category_blog_id},
  };
}
#$mt_category = {
#};

sub migrate_categories {
  my $in_sth = $in_dbh->prepare('SELECT * FROM mt_category ORDER BY category_id');
  my $out_sth = $out_dbh->prepare(
    'INSERT INTO category(id,name,slug,user_id) VALUES(?,?,?,?)'
  );
  my $out_blog_sth = $out_dbh->prepare(
    'INSERT INTO blog_categories(blog_id,category_id) VALUES(?,?)'
  );
  $in_sth->execute();

  my $count  = 0;
  while ( my $in_category = $in_sth->fetchrow_hashref ) {
    print '.' if $count++ % 100 == 0;
#use Data::Dumper; print Dumper($in_category);
#last;
    my $out_category = map_category($in_category);
    $out_sth->execute(
        @{$out_category}{qw( id name slug user_id )}
    );
    $out_blog_sth->execute(
        @{$out_category}{qw( blog_id id )}
    );
  }
}

###############################################################################

sub synthesize_post_tags {
  my $in_sth = $in_dbh->prepare(
    'SELECT objecttag_id, objecttag_tag_id
       FROM mt_objecttag
   ORDER BY objecttag_id');
  my %post_tag;
  my $count = 0;

  $in_sth->execute;
  while ( my $in_category = $in_sth->fetchrow_hashref ) {
    print '.' if $count++ % 100 == 0;
#use Data::Dumper; print Dumper($in_category);
#last;
    push @{ $post_tag{$in_category->{objecttag_id} } },
      $in_category->{objecttag_tag_id};
  }

  my $out_sth = $out_dbh->prepare(
    'insert into post_tag(tag_id,post_id) values(?,?)');

  die "*** post_tag has no data!\n" unless keys %post_tag;

  $count = 0;
  for my $post_id ( keys %post_tag ) {

    unless ( $post_tag{$post_id} and @{ $post_tag{$post_id} } ) {
      warn "*** Skipping post ID $post_id: no tags\n";
      next;
    }

    for my $tag_id ( @{ $post_tag{$post_id} } ) {
      print '.' if $count++ % 100 == 0;
      $out_sth->execute($tag_id,$post_id);
    }
  }
}

###############################################################################

sub synthesize_post_categories {
  my $in_sth = $in_dbh->prepare(
    'SELECT category_id, category_blog_id
       FROM mt_category
   ORDER BY category_id');
  my %blog_category;
  my $count = 0;

  $in_sth->execute;
  while ( my $in_category = $in_sth->fetchrow_hashref ) {
    print '.' if $count++ % 100 == 0;
#use Data::Dumper; print Dumper($in_category);
#last;
    push @{ $blog_category{ $in_category->{category_blog_id} } },
      $in_category->{category_id};
  }

  my $out_sth = $out_dbh->prepare(
    'insert into post_category(post_id,category_id) values(?,?)');

  die "*** blog_category has no data!\n" unless keys %blog_category;
  die "*** user_post has no data!\n" unless keys %user_post;

  $count = 0;
  for my $blog_id ( keys %blog_category ) {
    my $user_id = $blog_user{$blog_id};

    unless ( $blog_category{$blog_id} and @{ $blog_category{$blog_id} } ) {
      warn "*** Skipping blog ID $blog_id: no categories\n";
      next;
    }
    
    for my $category_id ( @{ $blog_category{$blog_id} } ) {

      unless ( $user_post{$user_id} and @{ $user_post{$user_id} } ) {
        warn "*** Skipping user ID $user_id: no posts\n";
        next;
      }

      for my $post_id ( @{ $user_post{$user_id} } ) {
        print '.' if $count++ % 100 == 0;
        $out_sth->execute($post_id,$category_id);
      }
    }
  }
}

###############################################################################

sub map_tag {
  my $tag = shift;
  my $dirified = dirify( $tag->{tag_name} );
  return {
    id   => $tag->{tag_id},
    name => decode_utf8($tag->{tag_name}),
    slug => decode_utf8($dirified),
  };
}
#$mt_tag = {
#};

sub migrate_tags {
  my $in_sth = $in_dbh->prepare('SELECT * FROM mt_tag ORDER BY tag_id');
  my $out_sth = $out_dbh->prepare(
    'INSERT INTO tag(id,name,slug) VALUES(?,?,?)'
  );
  $in_sth->execute();

  my $count  = 0;
  while ( my $in_tag = $in_sth->fetchrow_hashref ) {
    print '.' if $count++ % 100 == 0;
#use Data::Dumper; print Dumper($in_tag);
#last;
    my $out_tag = map_tag($in_tag);
    $out_sth->execute(
        @{$out_tag}{qw( id name slug )}
    );
  }
}

###############################################################################

sub map_asset {
  my $asset = shift;
  return {
    id        => $asset->{asset_id},
    blog_id   => $asset->{asset_blog_id},
    user_id   => $asset->{asset_created_by},
    file_ext  => $asset->{asset_file_ext},
    file_name => $asset->{asset_file_name},
    file_path => $asset->{asset_file_path},
  };
}

sub migrate_assets {
  my $in_sth = $in_dbh->prepare('SELECT * FROM mt_asset ORDER BY asset_id');
  my @fields = qw( id blog_id user_id file_ext file_name file_path );
  my $out_sth = $out_dbh->prepare(
    'INSERT INTO asset(id,blog_id,user_id,file_ext,file_name,file_path) VALUES(?,?,?,?,?,?)'
  );
  $in_sth->execute();

  my $count  = 0;
  while ( my $in_asset = $in_sth->fetchrow_hashref ) {
    print '.' if $count++ % 100 == 0;
    next if $in_asset->{asset_blog_id} == 0; # XXX Avatar assets are skipped.
#use Data::Dumper; print Dumper($in_asset);
#last;
    my $out_asset = map_asset($in_asset);
    $out_sth->execute( @{$out_asset}{@fields} );
  }
}

###############################################################################

sub update_sequences {
  my @tables = qw( users blog post comment category tag asset  );

  for my $table_name ( @tables ) {
    $out_dbh->do( <<"EOS" );
select setval('${table_name}_id_seq',
                ( select max( id ) from ${table_name} ) + 1, true )
EOS
  }

}

###############################################################################

print "migrating users: ";
migrate_users;
print "\n";

print "creating user avatars: ";
create_avatars;
print "\n";

print "migrating blogs: ";
migrate_blogs;
print "\n";

print "migrating posts: ";
migrate_posts;
print "\n";

print "migrating comments: ";
migrate_comments;
print "\n";

print "migrating categories: ";
migrate_categories;
print "\n";

print "migrating tags: ";
migrate_tags;
print "\n";

print "synthesizing post tags ";
synthesize_post_tags;
print "\n";

print "synthesizing post categories ";
synthesize_post_categories;
print "\n";

print "migrating assets: ";
migrate_assets;
print "\n";

print "Updating sequences: ";
update_sequences;
print "\n";
