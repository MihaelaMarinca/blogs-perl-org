#!/usr/bin/env perl

use strict;
use warnings;

use Encode;

use DBI;
use String::Dirify qw( dirify );
use Try::Tiny;
use Getopt::Long;

my ( $in_driver,   $out_driver   ) = ( 'mysql', 'Pg' );
my ( $in_database, $out_database ) = ( 'mt_blogs_perl_org', 'blogs_perl_org' );
my ( $in_user,     $out_user     ) = ( 'root', 'jgoff' );
my ( $in_password, $out_password ) = ( '', '' );

GetOptions(
  'in-driver=s'  => \$in_driver,
  'out-driver=s' => \$out_driver,
  'in-db=s'      => \$in_database,
  'out-db=s'     => \$out_database,
  'in-user=s'    => \$in_user,
  'out-user=s'   => \$out_user,
);

my $in_dsn  = "dbi:$in_driver:database=$in_database";
my $out_dsn = "dbi:$out_driver:database=$out_database";

my $in_dbh  = DBI->connect( $in_dsn, $in_user, $in_password );
my $out_dbh = DBI->connect( $out_dsn, $out_user, $out_password );

$|++;

my $AVATAR_PATH   = '/avatars';
my $PER_USER_PATH = '/users';

sub munge_asset_file_path {
  my $in_asset = shift;
  $in_asset->{asset_file_path} =~ s{^\%s}{$AVATAR_PATH};
  $in_asset->{asset_file_path} =~
    s{^\%r}{$PER_USER_PATH/$in_asset->{author_basename}};
}

###############################################################################

sub map_user {
  my $user = shift;
  return {
    id                 => $user->{author_id},
    name               => decode_utf8($user->{author_nickname}),
    username           => $user->{author_name},
    password           => $user->{author_password},
    preferred_language => $user->{author_preferred_language},
    register_date      => $user->{author_created_on},
    email              => decode_utf8($user->{author_email}),
    role               => $user->{author_is_superuser} ? 'admin' : 'author',
    status             => $user->{author_status} == 1 ? 'active' : 'inactive',
    biography          => decode_utf8($user->{author_meta_vclob}),
  };
}

sub migrate_users {
  my $in_sth = $in_dbh->prepare( <<'EOS' );
   SELECT a.author_id,
          a.author_nickname,
          a.author_name,
          a.author_password,
          a.author_preferred_language,
          a.author_created_on,
          a.author_email,
          a.author_is_superuser,
          a.author_status,
          am.author_meta_vclob
     FROM mt_author a
LEFT JOIN mt_author_meta am
       ON a.author_id = am.author_meta_author_id
    WHERE am.author_meta_type = 'field.about_blurb'
 GROUP BY a.author_id
 ORDER BY a.author_id
EOS

  my @fields = qw( id name username password status preferred_language register_date email role biography );
  my $out_sth = $out_dbh->prepare( <<'EOS' );
INSERT INTO users(id,
                  name,
                  username,
                  password,
                  status,
                  preferred_language,
                  register_date,
                  email,
                  role,
                  biography)
           VALUES(?,?,?,?,?,?,?,?,?,?)
EOS

  $in_sth->execute();

  my $count = 0;
  while ( my $in_user = $in_sth->fetchrow_hashref  ) {
    print '.' if $count++ % 100 == 0;
#use Data::Dumper; print Dumper($in_user);
#last;
    my $out_user = map_user($in_user);
    try {
      $out_sth->execute(
        @{$out_user}{@fields}
      );
    }
    catch {
      die "Failed to insert user '$in_user->{name}: $_ $!\n";
    };
  }
}

###############################################################################

sub create_avatars {
  my $in_sth = $in_dbh->prepare( <<EOS );
SELECT author_id,
       author_basename,
       asset_file_path
  FROM mt_asset
  JOIN mt_author
    ON author_userpic_asset_id = asset_id
EOS

  my $out_sth = $out_dbh->prepare( <<'EOS' );
UPDATE users SET avatar_path = ? WHERE id = ?
EOS

  $in_sth->execute;

  my $count = 0;
  while ( my $in_asset = $in_sth->fetchrow_hashref ) {
    print '.' if $count++ % 100 == 0;
    munge_asset_file_path( $in_asset );
#use Data::Dumper; print Dumper($in_user);
#last;
    try {
      $out_sth->execute( $in_asset->{asset_file_path}, $in_asset->{author_id} );
    }
    catch {
      die "Failed to create avatar for '$in_asset->{author_id}: $_ $!\n";
    };
  }
}

###############################################################################

sub map_blog {
  my $blog = shift;
  my $dirified = dirify( $blog->{blog_description} );
  return {
    id           => $blog->{blog_id},
    user_id      => $blog->{association_author_id},
    name         => decode_utf8( $blog->{blog_name} ),
    slug         => decode_utf8( $dirified ),
    description  => decode_utf8( $blog->{blog_description} ),
    created_date => $blog->{blog_created_on},
    edited_date  => $blog->{blog_modified_on},
  };
}

my %blog_user; # key $blog_id, value $user_id

sub migrate_blogs {
  my $in_sth = $in_dbh->prepare( <<'EOS' );
   SELECT b.blog_id,
          a.association_author_id,
          b.blog_name,
          b.blog_description,
          b.blog_created_on,
          b.blog_modified_on
     FROM mt_blog b
LEFT JOIN mt_association a
       ON b.blog_id = a.association_blog_id
ORDER BY blog_id
EOS

  my @fields = qw( id name slug description created_date edited_date );
  my $out_sth = $out_dbh->prepare( <<'EOS' );
INSERT INTO blog(id,name,slug,description,created_date,edited_date)
          VALUES(?,?,?,?,?,?)
EOS

  my $out_owner_sth = $out_dbh->prepare( <<'EOS' );
INSERT INTO blog_owners(blog_id,user_id)
          VALUES(?,?)
EOS

  $in_sth->execute;

  my $count  = 0;
  while ( my $in_blog = $in_sth->fetchrow_hashref ) {
    print '.' if $count++ % 100 == 0;

#use Data::Dumper; print Dumper($in_blog);
#last;
    my $out_blog = map_blog( $in_blog );
    next if $out_blog->{name} eq 'blogs.perl.org'; # Skip admin "user"

    $out_sth->execute( @{$out_blog}{@fields} );

    $blog_user{$out_blog->{id}} = $out_blog->{user_id};
    $out_owner_sth->execute($out_blog->{id},$out_blog->{user_id});
  }
}

###############################################################################

sub map_post {
  my $post     = shift;
  my $dirified = dirify( $post->{entry_title} );
  my $content  = $post->{entry_text};
  $content .= ' ' . $post->{entry_text_more};
  return {
    id           => $post->{entry_id},
    title        => decode_utf8($post->{entry_title}),
    slug         => decode_utf8($dirified),
    description  => $post->{entry_basename}, # XXX ?
    #cover varchar(300) NOT NULL,
    summary      => decode_utf8($post->{entry_text}),
    content      => decode_utf8($content),
    keywords      => decode_utf8($post->{entry_keywords}),
    created_date => $post->{entry_authored_on},
    #type post_format DEFAULT 'HTML',
    #status post_status DEFAULT 'draft',
    status       => 'published', # XXX Imported posts are already published
    user_id      => $post->{entry_author_id},
    blog_id      => $post->{entry_blog_id},
  };
}

my %user_post; #key $user_id, value @{ $post_id }
my %blog_post; #key $blog_id, value @{ $post }
my %tag;
my %post_keyword; #key $post_id, value @{ $tag_name }
my %keyword_post; #key $keyword_name, value @{ $post_id }

sub migrate_posts {
  my ( $tag ) = @_;
  my $in_sth = $in_dbh->prepare( <<'EOS' );
  SELECT entry_title,
         entry_text,
         entry_text_more,
         entry_id,
         entry_title,
         entry_basename,
         entry_text,
         entry_keywords,
         entry_authored_on,
         entry_author_id,
         entry_blog_id
         FROM mt_entry
ORDER BY entry_id
EOS

  my @fields =
    qw(id title slug description summary content created_date status user_id);
  my $out_sth = $out_dbh->prepare( <<'EOS' );
INSERT INTO post(id,title,slug,description,summary,content,created_date,status,user_id)
          VALUES(?,?,?,?,?,?,?,?,?)
EOS

  $in_sth->execute();

  my $count  = 0;
  while ( my $in_post = $in_sth->fetchrow_hashref ) {
    print '.' if $count++ % 100 == 0;
#use Data::Dumper; print Dumper($in_post);
#last;
    my $out_post = map_post( $in_post );
    push @{ $user_post{ $out_post->{user_id} } }, $out_post->{id};
    push @{ $blog_post{ $out_post->{blog_id} } }, $out_post->{id};
    if ( $out_post->{keywords} ) {
        my @tag = split /\s*,\s*/, $out_post->{keywords};
        $tag->{$_} = 1 for @tag;
        $post_keyword{$out_post->{id}} = \@tag;
        push @{ $keyword_post{$_} }, $out_post->{id} for @tag;
    }
    $out_sth->execute( @{$out_post}{@fields} );
  }
}

sub migrate_some_tags {
  my ( $tag ) = @_;
  my $in_sth = $in_dbh->prepare( <<'EOS' );
    SELECT objecttag_id, t.tag_name
      FROM mt_objecttag ot
      JOIN mt_tag t
        ON t.tag_id = ot.objecttag_tag_id
  ORDER BY objecttag_id
EOS

  my %post_tag;

  $in_sth->execute;

  my $count = 0;
  while ( my $in_category = $in_sth->fetchrow_hashref ) {
    print '.' if $count++ % 100 == 0;
    $tag->{$in_category->{tag_name}} = 1;
  }
}

###############################################################################

sub synthesize_tags {
  my ( $tag ) = @_;
  my $out_sth = $out_dbh->prepare( <<'EOS' );
INSERT INTO tag( id, name, slug )
            VALUES( ?, ?, ? )
EOS

  my $count = 0;

  my $index = 1;
  for my $name ( sort keys %{ $tag } ) {
    print '.' if $count++ % 100 == 0;

    $tag->{$name} = $index++;
    $out_sth->execute($tag->{$name}, $name, dirify( $name ));
  }
}

###############################################################################

sub synthesize_post_tags {
  my ( $tag ) = @_;
  my $out_sth = $out_dbh->prepare( <<'EOS' );
INSERT INTO post_tag( post_id, tag_id ) VALUES( ?, ? )
EOS

  my $count = 0;
  for my $post_id ( keys %post_keyword ) {

    unless ( $post_keyword{$post_id} and @{ $post_keyword{$post_id} } ) {
      warn "*** Skipping post ID $post_id: no tags\n";
      next;
    }

    for my $keyword_name ( @{ $post_keyword{$post_id} } ) {
      print '.' if $count++ % 100 == 0;

      my $tag_id = $tag->{$keyword_name};

      $out_sth->execute($post_id, $tag_id);
    }
  }
}

###############################################################################

sub map_comment {
  my $comment = shift;
  return {
    id           => $comment->{comment_id},
    content      => decode_utf8($comment->{comment_text}),
    fullname     => $comment->{comment_author},
    email        => $comment->{comment_email},
    website      => $comment->{comment_url},
#  avatar varchar(255) DEFAULT NULL,
    comment_date => $comment->{comment_created_on},
#  type post_format DEFAULT 'HTML', # Remain default
    status       => $comment->{comment_visible} == 1 ? 'approved' : 'pending',
    post_id      => $comment->{comment_entry_id},
    uid          => $comment->{comment_commenter_id},
  };
}

sub migrate_comments {
  my $in_sth = $in_dbh->prepare('SELECT * FROM mt_comment ORDER BY comment_id');
  my @fields = qw( id content fullname email website comment_date status post_id uid reply_to );
  my $out_sth = $out_dbh->prepare( <<'EOS' );
INSERT INTO comment(id,
                    content,
                    fullname,
                    email,
                    website,
                    comment_date,
                    status,
                    post_id,
                    uid,
                    reply_to)
            VALUES(?,?,?,?,?,?,?,?,?,?)
EOS
  $in_sth->execute();

  my $count  = 0;
  while ( my $in_comment = $in_sth->fetchrow_hashref ) {
    print '.' if $count++ % 100 == 0;
    next unless $in_comment->{comment_commenter_id}; # XXX Eliminate spam?
#use Data::Dumper; print Dumper($in_comment);
#last;
    my $out_comment = map_comment($in_comment);
    $out_sth->execute(
        @{$out_comment}{@fields}
    );
  }
}

###############################################################################

sub map_category {
  my $category = shift;
  my $dirified = dirify( $category->{category_label} );
  return {
    id      => $category->{category_id},
    name    => decode_utf8($category->{category_label}),
    slug    => decode_utf8($dirified),
    user_id => $category->{category_author_id},
    blog_id => $category->{category_blog_id},
  };
}

sub migrate_categories {
  my $in_sth = $in_dbh->prepare('SELECT * FROM mt_category ORDER BY category_id');
  my $out_sth = $out_dbh->prepare(
    'INSERT INTO category(id,name,slug,user_id) VALUES(?,?,?,?)'
  );
  my $out_blog_sth = $out_dbh->prepare(
    'INSERT INTO blog_categories(blog_id,category_id) VALUES(?,?)'
  );
  $in_sth->execute();

  my $count  = 0;
  while ( my $in_category = $in_sth->fetchrow_hashref ) {
    print '.' if $count++ % 100 == 0;
#use Data::Dumper; print Dumper($in_category);
#last;
    my $out_category = map_category($in_category);
    $out_sth->execute(
        @{$out_category}{qw( id name slug user_id )}
    );
    $out_blog_sth->execute(
        @{$out_category}{qw( blog_id id )}
    );
  }
}

###############################################################################

sub map_post_category {
  my $post_category = shift;
  return {
    category_id => $post_category->{category_id},
    blog_id     => $post_category->{blog_id},
  };
}

sub synthesize_post_categories {
  my $in_sth = $in_dbh->prepare( <<'EOS' );
SELECT c.category_id,
       b.blog_id
  FROM mt_category c
  JOIN mt_blog b
    ON c.category_id = b.blog_id
EOS

  my $out_sth = $out_dbh->prepare( <<'EOS' );
INSERT INTO post_category( post_id, category_id ) VALUES( ?, ? )
EOS

  my $count = 0;

  $in_sth->execute;
  while ( my $in_blog_category = $in_sth->fetchrow_hashref ) {
    print '.' if $count++ % 100 == 0;
    my $out_blog_category = map_post_category( $in_blog_category );
#use Data::Dumper; print Dumper($in_category);
#last;

    for my $post_id ( @{ $blog_post{$out_blog_category->{blog_id}} } ) {
      print '.' if $count++ % 100 == 0;

      $out_sth->execute($post_id, $out_blog_category->{category_id});
    }
  }
}

###############################################################################

sub map_asset {
  my $asset = shift;
  return {
    id        => $asset->{asset_id},
    blog_id   => $asset->{asset_blog_id},
    user_id   => $asset->{asset_created_by},
    file_ext  => $asset->{asset_file_ext},
    file_name => $asset->{asset_file_name},
    file_path => $asset->{asset_file_path},
  };
}

sub migrate_assets {
  my $in_sth = $in_dbh->prepare('SELECT * FROM mt_asset ORDER BY asset_id');
  my @fields = qw( id blog_id user_id file_ext file_name file_path );
  my $out_sth = $out_dbh->prepare(
    'INSERT INTO asset(id,blog_id,user_id,file_ext,file_name,file_path) VALUES(?,?,?,?,?,?)'
  );
  $in_sth->execute();

  my $count  = 0;
  while ( my $in_asset = $in_sth->fetchrow_hashref ) {
    print '.' if $count++ % 100 == 0;
    next if $in_asset->{asset_blog_id} == 0; # XXX Avatar assets are skipped.
#use Data::Dumper; print Dumper($in_asset);
#last;
    my $out_asset = map_asset($in_asset);
    $out_sth->execute( @{$out_asset}{@fields} );
  }
}

###############################################################################

sub update_sequences {
  my @tables = qw( users blog post comment category tag asset  );

  for my $table_name ( @tables ) {
    $out_dbh->do( <<"EOS" );
select setval('${table_name}_id_seq',
                ( select max( id ) from ${table_name} ) + 1, true )
EOS
  }

}

###############################################################################

print "migrating users: ";
migrate_users;
print "\n";

print "creating user avatars: ";
create_avatars;
print "\n";

print "migrating blogs: ";
migrate_blogs;
print "\n";

print "migrating posts: ";
migrate_posts( \%tag );
print "\n";

print "migrating some posts: ";
migrate_some_tags( \%tag );
print "\n";

print "synthesizing tags ";
synthesize_tags( \%tag );
print "\n";

print "synthesizing post tags ";
synthesize_post_tags( \%tag );
print "\n";

print "migrating comments: ";
migrate_comments;
print "\n";

print "migrating categories: ";
migrate_categories;
print "\n";

print "synthesizing post categories ";
synthesize_post_categories;
print "\n";

print "migrating assets: ";
migrate_assets;
print "\n";

print "Updating sequences: ";
update_sequences;
print "\n";
